apiVersion: v1
kind: Namespace
metadata:
  name: app-157

---
apiVersion: v1
kind: Secret
metadata:
  name: data-processor-app
  namespace: app-157
type: Opaque
stringData:
  app.py: |
    import os
    import time
    import random
    import json
    from datetime import datetime

    class DataProcessor:
        def __init__(self):
            self.data_dir = "/data"
            self.batch_size = 1000
            self.file_counter = 0
            print(f"[{datetime.now()}] Starting Data Analytics Processor v2.4.1")
            print(f"[{datetime.now()}] Configuration: Data repository at {self.data_dir}")
            print(f"[{datetime.now()}] Configuration: Batch size set to {self.batch_size} records for optimal throughput")

            # Ensure data directory exists
            os.makedirs(self.data_dir, exist_ok=True)

        def generate_analytics_data(self, batch_id):
            """Generate realistic analytics data"""
            data = []
            for i in range(self.batch_size):
                record = {
                    "timestamp": datetime.now().isoformat(),
                    "user_id": f"user_{random.randint(1000, 9999)}",
                    "session_id": f"session_{random.randint(100000, 999999)}",
                    "event_type": random.choice(["page_view", "click", "purchase", "search", "login"]),
                    "page_url": f"/product/{random.randint(1, 1000)}",
                    "user_agent": "Mozilla/5.0 (compatible; DataCollector/1.0)",
                    "ip_address": f"{random.randint(1,255)}.{random.randint(1,255)}.{random.randint(1,255)}.{random.randint(1,255)}",
                    "metrics": {
                        "load_time": random.uniform(0.1, 3.0),
                        "cpu_usage": random.uniform(0, 100),
                        "memory_usage": random.uniform(0, 100),
                        "disk_io": random.randint(0, 1000)
                    },
                    "metadata": {
                        "platform": random.choice(["web", "mobile", "tablet"]),
                        "country": random.choice(["US", "UK", "DE", "FR", "JP", "AU"]),
                        "device_type": random.choice(["desktop", "mobile", "tablet"]),
                        "batch_id": batch_id
                    }
                }
                data.append(record)
            return data

        def save_batch_data(self, batch_id, data):
            """Save batch data to disk"""
            # Check disk space before saving batch data
            self.check_disk_space_limit()

            filename = f"{self.data_dir}/analytics_batch_{batch_id:06d}.json"
            with open(filename, 'w') as f:
                json.dump(data, f, indent=2)

            # Create processing artifacts
            # Processing audit log
            log_filename = f"{self.data_dir}/audit_{batch_id:06d}.log"
            with open(log_filename, 'w') as f:
                for record in data:
                    f.write(f"AUDIT: {record['timestamp']} - {record['user_id']} - {record['event_type']} - processed\n")

            # Feature extraction results
            features_filename = f"{self.data_dir}/features_{batch_id:06d}.dat"
            with open(features_filename, 'wb') as f:
                # Feature vectors for ML pipeline
                f.write(os.urandom(1500000))  # 1.5MB feature data per batch

            # Model predictions cache
            predictions_filename = f"{self.data_dir}/predictions_{batch_id:06d}.cache"
            with open(predictions_filename, 'wb') as f:
                f.write(os.urandom(2500000))  # 2.5MB predictions cache per batch

            return filename

        def get_folder_size(self, folder_path):
            """Calculate total size of files in folder"""
            total_size = 0
            try:
                for dirpath, dirnames, filenames in os.walk(folder_path):
                    for filename in filenames:
                        filepath = os.path.join(dirpath, filename)
                        if os.path.exists(filepath):
                            total_size += os.path.getsize(filepath)
            except (OSError, IOError):
                pass
            return total_size

        def check_disk_space_limit(self):
            """Check if folder size exceeds 100MB and simulate disk full
            This simulates disk space limits when the PVC's limit is not enforced (e.g. local kind cluster)
            """
            folder_size = self.get_folder_size(self.data_dir)
            if folder_size >= 100 * 1024 * 1024:  # 100MB limit
                raise OSError(28, "No space left on device")

        def initialize_historical_data(self):
            """Initialize historical data repository for analytics"""
            print(f"[{datetime.now()}] Initializing historical data repository...")

            # Check if we have persistent state from previous runs
            state_file = f"{self.data_dir}/.processing_state"
            if os.path.exists(state_file):
                with open(state_file, 'r') as f:
                    state = f.read().strip()
                if state == "storage_error":
                    print(f"[{datetime.now()}] ERROR: Previous run encountered storage issues - cannot initialize repository")
                    print(f"[{datetime.now()}] CRITICAL: Insufficient storage space for historical data requirements")
                    raise OSError("[Errno 28] No space left on device")

            try:
                # Initialize the historical data repository with seed data
                print(f"[{datetime.now()}] Loading historical analytics dataset...")
                historical_file = f"{self.data_dir}/historical_analytics.dat"

                with open(historical_file, 'wb') as f:
                    # Load historical data for trend analysis (realistic for analytics)
                    months_of_data = 24  # 2 years of historical data
                    for month in range(months_of_data):
                        # Check disk space before writing each month
                        self.check_disk_space_limit()

                        # Each month contains user interaction data
                        monthly_data_size = 50 * 1024 * 1024  # 50MB per month is realistic
                        f.write(os.urandom(monthly_data_size))

                        if month % 6 == 0 and month > 0:
                            print(f"[{datetime.now()}] Loaded {month} months of historical data for trend analysis")

                print(f"[{datetime.now()}] Historical data repository initialized successfully")

            except OSError as e:
                if "No space left on device" in str(e) or e.errno == 28:
                    # Mark the storage error state
                    try:
                        with open(state_file, 'w') as f:
                            f.write("storage_error")
                    except:
                        pass
                    print(f"[{datetime.now()}] ERROR: Failed to initialize historical data repository")
                    print(f"[{datetime.now()}] CRITICAL: Unable to load required historical dataset - insufficient storage")
                    exit(1)
                else:
                    raise

        def process_data_continuously(self):
            """Main processing loop"""
            # Initialize historical data repository first
            self.initialize_historical_data()

            batch_id = 0

            print(f"[{datetime.now()}] Starting real-time analytics processing...")
            print(f"[{datetime.now()}] Mode: Continuous processing with historical data integration")

            while True:
                try:
                    batch_id += 1
                    print(f"[{datetime.now()}] Processing batch {batch_id}")

                    # Generate analytics data
                    data = self.generate_analytics_data(batch_id)

                    # Save to disk
                    filename = self.save_batch_data(batch_id, data)
                    print(f"[{datetime.now()}] Completed batch {batch_id} - {len(data)} records processed")

                    # Periodic health checks
                    if batch_id % 10 == 0:
                        print(f"[{datetime.now()}] Health check: System operational, processing pipeline active")

                    # Progress reporting
                    if batch_id % 25 == 0:
                        print(f"[{datetime.now()}] Progress update: Processed {batch_id * self.batch_size} user interactions")
                        print(f"[{datetime.now()}] Quality metrics: Data validation passed, feature extraction complete")

                    # Small delay between batches
                    time.sleep(0.01)

                except OSError as e:
                    if "No space left on device" in str(e):
                        print(f"[{datetime.now()}] CRITICAL ERROR: Failed to write batch {batch_id} - storage capacity exceeded")
                        print(f"[{datetime.now()}] ERROR: No space left on device while processing analytics data")
                        print(f"[{datetime.now()}] System cannot continue data processing operations")
                        exit(1)
                    else:
                        print(f"[{datetime.now()}] ERROR: I/O error while processing batch {batch_id}: {e}")
                        exit(1)
                except Exception as e:
                    print(f"[{datetime.now()}] ERROR: Unexpected error in batch {batch_id}: {e}")
                    raise

    if __name__ == "__main__":
        processor = DataProcessor()
        processor.process_data_continuously()

---
apiVersion: v1
kind: Service
metadata:
  name: data-processor
  namespace: app-157
  labels:
    app: data-processor
spec:
  clusterIP: None
  selector:
    app: data-processor
  ports:
  - name: metrics
    port: 8080
    targetPort: 8080

---
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: data-processor
  namespace: app-157
  labels:
    app: data-processor
spec:
  replicas: 1
  selector:
    matchLabels:
      app: data-processor
  serviceName: "data-processor"
  template:
    metadata:
      labels:
        app: data-processor
    spec:
      securityContext:
        fsGroup: 1000
        runAsNonRoot: true
        runAsUser: 1000
      containers:
      - name: data-processor
        image: python:3.9-slim
        command: ["python", "/app/app.py"]
        env:
        - name: PYTHONUNBUFFERED
          value: "1"
        - name: SERVICE_NAME
          value: "data-analytics-processor"
        - name: LOG_LEVEL
          value: "INFO"
        resources:
          requests:
            memory: "256Mi"
            cpu: "50m"
          limits:
            memory: "512Mi"
            cpu: "100m"
        volumeMounts:
        - name: app-code
          mountPath: /app
        - name: data-storage
          mountPath: /data
      volumes:
      - name: app-code
        secret:
          secretName: data-processor-app
          defaultMode: 0755
  volumeClaimTemplates:
  - metadata:
      name: data-storage
    spec:
      accessModes: [ "ReadWriteOnce" ]
      resources:
        requests:
          storage: 100Mi
