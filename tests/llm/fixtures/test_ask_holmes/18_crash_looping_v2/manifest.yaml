apiVersion: v1
kind: Namespace
metadata:
  name: app-18
---
apiVersion: v1
kind: Secret
metadata:
  name: flask-app-code
  namespace: app-18
type: Opaque
stringData:
  app.py: |
    #!/usr/bin/env python3
    import logging
    import threading
    import time
    import os
    import sys
    import requests
    from datetime import datetime
    from flask import Flask

    # Configure logging for both Flask and requests
    logging.basicConfig(
        level=logging.DEBUG,
        format='%(asctime)s - %(levelname)s - %(message)s'
    )
    logging.getLogger('urllib3').setLevel(logging.DEBUG)

    app = Flask(__name__)

    class ExpiredCertException(Exception):
        pass

    def make_self_requests():
        """Make some requests to self to generate logs"""
        try:
            for _ in range(3):
                logging.debug("Starting new HTTP connection (1): localhost:5000")
                response = requests.get('http://localhost:5000/')
                logging.debug(f'http://localhost:5000 "GET / HTTP/10" {response.status_code} {len(response.content)}')
                time.sleep(0.5)
        except:
            pass  # Ignore errors if server is shutting down

    def check_certificate_expiry():
        """Check certificate expiry after a short delay"""
        # Make some self-requests first
        make_self_requests()

        logging.info("Validating cert")

        # Simulate an expired certificate
        cert_expiry = "2024-08-03 17:00:08"
        logging.warning("Certificate has expired. Update the ssl certificate using the '/update_certificate' API or update the config map.")
        logging.error("SSL certificate expired")

        # Force the entire process to exit
        try:
            raise ExpiredCertException(f"Certificate expired on {cert_expiry}")
        except ExpiredCertException as e:
            # Print traceback in the expected format
            print("Traceback (most recent call last):", file=sys.stderr)
            print('  File "/app/app.py", line 141, in check_certificate_expiry', file=sys.stderr)
            print(f'    raise ExpiredCertException(f"Certificate expired on {{cert_expiry}}")', file=sys.stderr)
            print(f"ExpiredCertException: {e}", file=sys.stderr)
            sys.stderr.flush()
            os._exit(1)  # Force exit to simulate crash

    @app.route('/')
    def home():
        return "Service is running", 200

    def start_certificate_check():
        """Start the certificate check thread"""
        logging.info("check_certificate_expiry thread started")
        thread = threading.Thread(target=check_certificate_expiry)
        thread.daemon = False  # Make it non-daemon so it can affect the main process
        thread.start()

    if __name__ == '__main__':
        # Configure werkzeug logger (Flask's underlying server)
        werkzeug_logger = logging.getLogger('werkzeug')
        werkzeug_logger.setLevel(logging.INFO)

        # Start the Flask app in a thread so we can make requests to it
        server_thread = threading.Thread(target=lambda: app.run(host='0.0.0.0', port=5000, debug=False, use_reloader=False))
        server_thread.daemon = True
        server_thread.start()

        # Give Flask time to start
        time.sleep(1)

        # Make initial request
        try:
            logging.debug("Starting new HTTP connection (1): localhost:5000")
            response = requests.get('http://localhost:5000/')
            logging.debug(f'http://localhost:5000 "GET / HTTP/10" {response.status_code} {len(response.content)}')
        except:
            pass

        # Start the certificate check thread after a brief delay
        timer = threading.Timer(2.0, start_certificate_check)
        timer.start()

        # Keep the main thread alive
        server_thread.join()
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: golden-eagle
  namespace: app-18
  labels:
    app: flask
spec:
  replicas: 1
  selector:
    matchLabels:
      app: flask
  template:
    metadata:
      labels:
        app: flask
    spec:
      containers:
      - name: flask
        image: python:3.9-slim
        command: ["sh", "-c", "pip install flask==2.3.3 requests==2.31.0 && python /app/app.py"]
        ports:
        - containerPort: 5000
        volumeMounts:
        - name: app-code
          mountPath: /app
        - name: cert-volume
          mountPath: /certs/certificate.pem
          subPath: certificate.pem
        - name: key-volume
          mountPath: /certs/key.pem
          subPath: key.pem
      volumes:
      - name: app-code
        secret:
          secretName: flask-app-code
      - name: cert-volume
        secret:
          secretName: db-certs-config
          items:
          - key: certificate.pem
            path: certificate.pem
      - name: key-volume
        secret:
          secretName: db-certs-config
          items:
          - key: key.pem
            path: key.pem
---
apiVersion: v1
kind: Service
metadata:
  name: flask-service
  namespace: app-18
  labels:
    app: flask
spec:
  selector:
    app: flask
  ports:
    - protocol: TCP
      name: http
      port: 80
      targetPort: 5000
